import os
import tkinter as tk
from tkinter import Tk, filedialog, messagebox

import joblib
import numpy as np
import pefile
import pyfiglet
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split


# Function to extract features from PE file
def extract_pe_features(file_path):
    try:
        pe = pefile.PE(file_path)
        features = [
            pe.FILE_HEADER.Machine,
            pe.FILE_HEADER.SizeOfOptionalHeader,
            pe.FILE_HEADER.Characteristics,
            pe.OPTIONAL_HEADER.Magic,
            pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            pe.OPTIONAL_HEADER.ImageBase,
            pe.OPTIONAL_HEADER.SectionAlignment,
            pe.OPTIONAL_HEADER.FileAlignment,
            pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
            pe.OPTIONAL_HEADER.MajorImageVersion,
            pe.OPTIONAL_HEADER.MajorSubsystemVersion,
            pe.OPTIONAL_HEADER.SizeOfImage,
            pe.OPTIONAL_HEADER.SizeOfHeaders,
            pe.OPTIONAL_HEADER.CheckSum,
            pe.OPTIONAL_HEADER.Subsystem,
            pe.OPTIONAL_HEADER.DllCharacteristics,
            pe.OPTIONAL_HEADER.SizeOfStackReserve,
            pe.OPTIONAL_HEADER.SizeOfStackCommit,
            pe.OPTIONAL_HEADER.SizeOfHeapReserve,
            pe.OPTIONAL_HEADER.SizeOfHeapCommit,
        ]
        return features
    except Exception as e:
        print(f"Error processing file {file_path}: {e}")
        return None


# Generate synthetic data for training
def create_pe_data():
    benign_features = [np.random.rand(20) for _ in range(100)]
    malicious_features = [np.random.rand(20) + 1 for _ in range(100)]
    features = benign_features + malicious_features
    labels = [0] * 100 + [1] * 100
    return np.array(features), np.array(labels)


# Train the PE model
def train_pe_model():
    features, labels = create_pe_data()
    X_train, X_test, y_train, y_test = train_test_split(
        features, labels, test_size=0.2, random_state=42
    )
    model = RandomForestClassifier()
    model.fit(X_train, y_train)
    joblib.dump(model, "pe_model.pkl")
    y_pred = model.predict(X_test)
    print("Model trained with accuracy:", accuracy_score(y_test, y_pred))


# Load the trained model
pe_model = joblib.load("pe_model.pkl")


# Function to scan a file
def scan_file():
    file_path = filedialog.askopenfilename(title="Select a file")
    if file_path:
        features = extract_pe_features(file_path)
        if features:
            features = np.array(features).reshape(1, -1)
            prediction = pe_model.predict(features)
            if prediction == 1:
                messagebox.showinfo("Result", "The file is malicious.")
            else:
                messagebox.showinfo("Result", "The file is clean.")


# Function to exit the application
def exit_app():
    root.quit()


# Set up the GUI
root = tk.Tk()
root.title("Malware Detector")

# Display the ASCII art
ascii_art = pyfiglet.figlet_format("Malware System Detector")
label_art = tk.Label(root, text=ascii_art, font=("Courier", 12), justify=tk.LEFT)
label_art.pack()

# Display welcome message
label_welcome = tk.Label(
    root, text="Welcome to malware detector\n", font=("Helvetica", 14)
)
label_welcome.pack()

# Create buttons for file scanning and exit
btn_scan = tk.Button(root, text="Scan File", command=scan_file, width=20)
btn_scan.pack(pady=10)

btn_exit = tk.Button(root, text="Exit", command=exit_app, width=20)
btn_exit.pack(pady=10)

# Train the model (only once, you can comment this out after the first run)
train_pe_model()

# Run the application
root.mainloop()
